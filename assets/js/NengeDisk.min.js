class NengeDisk{DB={};mountPath=[];constructor(t,e){t&&this.pathToDB(e||"MyEmu",t)}SetModule(t){Object.defineProperty(this,"Module",{get:()=>t})}get FS(){return this.Module.FS||window.FS}get MEMFS(){return this.Module.MEMFS||this.FS.filesystems.MEMFS}get HEAP8(){return this.Module.HEAP8||self.HEAP8}getStore(t){if(t.mountpoint)return this.DB[t.mountpoint]}mount(t){let e=t.mountpoint;return this.DB[e]||this.mountPath.push(e),this.MEMFS.mount.apply(null,arguments)}async syncfs(t,e,s){let r=this;r.mountPath.length&&(this.pathToDB("MyEmuData",Object.fromEntries(r.mountPath.map((t=>[t,t])))),r.mountPath=[]);let n,i=r.getStore(t);return i&&(t.isReady?n=await r.syncWrite(i,t):(n=await this.loadFile(i).catch((t=>alert(t))),t.isReady=!0)),e&&e instanceof Function&&e("ok"),s&&s instanceof Function&&s("ok"),n}async loadFile(t){let e=this;return Object.entries(await t.all(!0)).map((t=>e.storeLocalEntry(t[0],t[1]))).join("\n")}syncUpdate(t,e){let s=this;if(!e)return clearTimeout(s.Timer),s.Timer=setTimeout((()=>s.syncUpdate(t,!0)),1e3);s.syncfs(t.node.mount)}setMEMFS(t){let e=this;this.Module.MEMFS?t||(t=e.MEMFS):Object.defineProperty(this.Module.MEMFS,{get:()=>t}),t.stream_ops.write=function(t,s,r,n,i,a){if(e.HEAP8&&s.buffer===e.HEAP8.buffer&&(a=!1),!n)return 0;var o=t.node;if(o.timestamp=Date.now(),s.subarray&&(!o.contents||o.contents.subarray)){if(a)return o.contents=s.subarray(r,r+n),o.usedBytes=n,n;if(0===o.usedBytes&&0===i)return o.contents=new Uint8Array(s.subarray(r,r+n)),o.usedBytes=n,e.syncUpdate(t),n;if(i+n<=o.usedBytes)return o.contents.set(s.subarray(r,r+n),i),n}if(e.MEMFS.expandFileStorage(o,i+n),o.contents.subarray&&s.subarray)o.contents.set(s.subarray(r,r+n),i);else for(var l=0;l<n;l++)o.contents[i+l]=s[r+l];return o.usedBytes=Math.max(o.usedBytes,i+n),n},t.stream_ops.msync=function(t){},t.ops_table&&(t.ops_table.file.stream.write=t.stream_ops.write),t.ops_table&&(t.ops_table.file.stream.msync=t.stream_ops.msync)}async syncWrite(t,e){let s=this.getLocalList(e.mountpoint,!0),r=await this.getRemoteList(t),n=[],i=[],a=[];Object.entries(s).forEach((t=>{(!r[t[0]]||t[1]>r[t[0]])&&n.push(t[0])})),Object.entries(r).forEach((t=>{s[t[0]]||i.push(t[0])}));let o=await t.transaction();return n.sort().forEach((t=>{o.put(this.loadLocalEntry(t),t),a.push("indexdb write:"+t)})),i.sort().forEach((t=>{o.delete(t),a.push("indexdb delete:"+t)})),this.log&&this.log(IsReady,a),a.join("\n")}loadLocalEntry(t){let e,s,r=this,n=r.FS;return n.analyzePath(t).exists?(s=n.lookupPath(t).node,e=n.stat(t),n.isDir(e.mode)?{timestamp:e.mtime,mode:e.mode}:n.isFile(e.mode)?(s.contents=r.getFileDataAsTypedArray(s),{timestamp:e.mtime,mode:e.mode,contents:s.contents}):"node type not supported"):t+" is exists"}storeLocalEntry(t,e){let s=this.FS;if(e&&e.mode){if(s.isDir(e.mode))!s.analyzePath(t).exists&&s.createPath("/",t,!0,!0);else{if(!s.isFile(e.mode))throw"node type not supported";{let r=t&&t.split("/").slice(0,-1).join("/");r&&!s.analyzePath(r).exists&&s.createPath("/",r,!0,!0),s.writeFile(t,e.contents,{canOwn:!0,encoding:"binary"})}}return s.chmod(t,e.mode),s.utime(t,e.timestamp,e.timestamp),"FS write:"+t}}removeLocalEntry(t){let e=this.FS;if(e.analyzePath(t).exists){var s=e.stat(t);return e.isDir(s.mode)?e.rmdir(t):e.isFile(s.mode)&&e.unlink(t),"FS unlink:"+t}return t+"is not exists"}async getRemoteList(t,e){let s=await t.cursor("timestamp",!0);return e&&e(s),s}getLocalList(t,e){t=t||"/";let s=this,r=s.FS,n={},i=[".",".."].concat("/"==t?["dev","tmp","proc"]:[]),a=t=>!e||!i.includes(t),o=t=>e=>s.join2(t,e),l=s.stat(t)&&r.readdir(t).filter(a).map(o(t));if(l){for(;l.length;){let i=l.shift();if(!e&&i==t)continue;let c=s.stat(i);s.Filter&&s.Filter(i)||c&&(n[i]=c.mtime,r.isDir(c.mode)&&e&&l.push.apply(l,r.readdir(i).filter(a).map(o(i))))}return n}}stat(t){let e=this.FS,s=e.analyzePath(t);if(s.exists&&s.object.node_ops&&s.object.node_ops.getattr)return e.stat(t)}getFileDataAsTypedArray(t){return t.contents?t.contents.subarray?t.contents.subarray(0,t.usedBytes):new Uint8Array(t.contents):new Uint8Array}join(){var t=Array.prototype.slice.call(arguments,0);return this.normalize(t.join("/"))}join2(t,e){return this.normalize(t+"/"+e)}normalize(t){var e="/"===t.charAt(0),s="/"===t.substring(-1);return(t=this.normalizeArray(t.split("/").filter((t=>!!t)),!e).join("/"))||e||(t="."),t&&s&&(t+="/"),(e?"/":"")+t}normalizeArray(t,e){for(var s=0,r=t.length-1;r>=0;r--){var n=t[r];"."===n?t.splice(r,1):".."===n?(t.splice(r,1),s++):s&&(t.splice(r,1),s--)}if(e)for(;s;s--)t.unshift("..");return t}ReadFile(t){if(this.FS.analyzePath(t).exists)return this.FS.readFile(t)}MKFILE(t,e,s){if(!this.Module)return;let r=this.FS,n=t.split("/");if(n=n.length?n.slice(0,-1).join("/"):"/",!r.analyzePath(n).exists){let t=n.split("/").slice(0,-1).join("/");r.analyzePath(t).exists||r.createPath("/",t,!0,!0),r.createPath("/",n,!0,!0)}"string"==typeof e&&(e=(new TextEncoder).encode(e)),s?(r.analyzePath(t).exists&&r.unlink(t),r.writeFile(t,e,{encoding:"binary"})):r.analyzePath(t).exists||r.writeFile(t,e,{encoding:"binary"})}StoreBase={};StoreTable={};pathToDB(t,e){let s=this,r=Object.entries(e),n=r.map((t=>t[1]));s.StoreBase[t]&&s.StoreBase[t].then((e=>{e.close(),s.StoreBase[t]=null})),r.forEach((e=>this.DB[e[0]]=new s.StoreClass(t,e[1],n,s)))}getDB(t,e){"string"==typeof e&&(e=[e]);let s=this;return s.StoreTable[e[0]]||e.forEach((r=>{s.StoreTable[r]=new s.StoreClass(t,r,e,s)})),s.StoreTable[e[0]]}StoreClass=class{constructor(t,e,s,r){this.NAME=t,this.table=e,this.TABLES=s,Object.defineProperty(this,"D",{get:()=>r})}idb(t){let e=this,s=e.NAME,r=e.TABLES,n=e.D;return!t&&n.StoreBase[s]&&n.StoreBase[s]instanceof Promise?n.StoreBase[s]:n.StoreBase[s]=new Promise((n=>{const i=indexedDB.open(s,t);i.onupgradeneeded=t=>{let e=i.result;r.forEach((t=>{if(!e.objectStoreNames.contains(t)){e.createObjectStore(t).createIndex("timestamp","timestamp",{unique:!1})}}))},i.onsuccess=t=>{let s=i.result;if(r.filter((t=>s.objectStoreNames.contains(t))).length==r.length)return n(s);s.close(),e.idb(s.version+1).then((t=>n(t)))},i.onerror=t=>n(null)}))}async transaction(t){t=t?"readonly":"readwrite";let e=this.table;return(await this.idb()).transaction([e],t).objectStore(e)}async getlist(t){let e=await this.transaction(!0),s={};return new Promise((r=>{(t?e.openCursor():e.index("timestamp").openKeyCursor()).onsuccess=e=>{let n=e.target.result;n?(s[n.primaryKey]=n[t?"value":"key"],n.continue()):r(s)}}))}async all(){return this.getlist(!0)}async cursor(){return this.getlist()}async findItem(t,e){let s=await this.transaction(!0);return new Promise((r=>{"string"==typeof t?s.get(t).onsuccess=t=>{let s=t.target.result;r(e?s[e]:s)}:Promise.all(t.map((t=>new Promise((r=>s.get(t).onsuccess=s=>{let n=s.target.result;r([t,e?n[e]:n])}))))).then((t=>r(Object.fromEntries(t.filter((t=>t[1]))))))}))}async removeItem(t){let e=await this.transaction();return new Promise((s=>{"string"==typeof t?e.delete(t).onsuccess=t=>s(t.target.result):Promise.all(t.map((t=>new Promise((s=>e.delete(t).onsuccess=t=>s(t.target.result)))))).then((t=>s(Object.fromEntries(t))))}))}async saveItem(t,e){let s=await this.transaction();e?new Promise((r=>s.put(t,e).onsuccess=t=>r(t.target.result))):Object.entries(t).map((t=>new Promise((e=>s.put(t[1],t[0]).onsuccess=t=>e(t.target.result)))))}async keys(){let t=await this.transaction(!0);return new Promise((e=>t.getAllKeys().onsuccess=t=>e(t.target.result)))}}}